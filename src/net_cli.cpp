#include "net_cli.hpp"

#include <iostream>
#include <fstream>
#include <codecvt>
#include <locale>
#include <algorithm>
#include <vector>
#include <iomanip>

#include <assembly/cli.hpp>

cli::opt_t net_options[] =
{
    { "help",       &help_net,      "Show this help message"        },
    { "test",       &net_test,      "Test something"                },
    { "load-gm",    &net_load_gm,   "Load game messages"            },

    {0,0,0}
};

int main_net(int argc, char** argv)
{
    int optind = 1;

    if (argc <= optind) {
        std::cout << "Usage: net <subcommand> ..." << std::endl;
        return 1;
    }

    return cli::call("NetCLI", net_options, argv[optind], argc - optind, argv + optind);
}

int help_net (int argc, char** argv)
{
    cli::help("NetCLI", net_options, "Packet/Network helper tool");
}

int net_test(int argc, char** argv)
{
    std::u16string test = u"Hello again! Tschüß!";
    std::wstring_convert<std::codecvt_utf8_utf16<char16_t>,char16_t> convert;
    std::string a = convert.to_bytes(test);
    std::cout << a << std::endl;
    return 0;
}

template <typename T>
struct optional
{
    std::unique_ptr<T> value;
};

struct struct_node_t
{
    std::string type;   // Typename
    std::string id;     // Id, valid variable name
    std::string init;   // Default value
};

int net_load_gm(int argc, char** argv)
{
    if (argc <= 2)
    {
        std::cout << "Usage: <gm-file> <outdir>" << std::endl;
        return 1;
    }

    std::ifstream file(argv[1]);
    if (!file.is_open())
    {
        std::cout << "Could not open '" << argv[1] << "'" << std::endl;
        return 2;
    }

    std::string base(argv[2]);
    std::string header_file(base + "game_messages.hpp");
    std::string impl_file(base + "game_messages.cpp");
    std::ofstream header(header_file);
    std::ofstream impl(impl_file);

    if (!header.is_open() || !impl.is_open())
    {
        std::cout << "Could not open '" << impl_file << "' or '" << header_file << "'" << std::endl;
        return 3;
    }

    std::string line;
    std::string name;
    std::vector<std::string> types;
    bool open = false;

    header << "#pragma once" << std::endl << std::endl;
    header << "/* This file was autogenerated by `paradox net load-gm` */" << std::endl;
    header << "#include \"types.hpp\"" << std::endl;
    header << "#include \"serialize.hpp\"" << std::endl << std::endl;
    header << std::left;

    impl << "#include \"game_messages.hpp\"" << std::endl << std::endl;
    impl << "/* This file was autogenerated by `paradox net load-gm` */" << std::endl;
    impl << std::endl;

    while(std::getline(file, line))
    {
        if (line.size() > 0)
        {
            char c = line.at(0);
            switch (c)
            {
                case '[':
                {
                    std::string::size_type idx = line.find_first_of(']');
                    std::string type = line.substr(1, idx - 1);
                    if (type == "std::wstring") type = "std::u16string";
                    std::string::size_type ixx = line.find_first_of(',', idx + 2);
                    std::string rest;
                    std::string def_val;
                    bool has_def = false;
                    if (ixx == std::string::npos)
                    {
                        rest = line.substr(idx + 4);
                    }
                    else
                    {
                        rest = line.substr(idx + 4, ixx - idx - 4);
                        std::string def = line.substr(ixx + 2);
                        if (def.size() >= 9 && def.substr(0,9) == "default: ")
                        {
                            def_val = def.substr(9);
                            has_def = true;
                        }
                    }

                    header << "    " << std::setw(20) << type << " " << rest << (has_def ? " = " + def_val + ";" : ";")<< std::endl;

                    if (type == "bit" || !has_def)
                    {
                        impl << "    serialize(bs, gm." << rest << ", write);" << std::endl;
                    }
                    else
                    {
                        impl << "    if (write ? writebit(bs, gm." << rest << " != " << def_val << ") : readbit(bs))" << std::endl;
                        impl << "    {" << std::endl;
                        impl << "        " << "serialize(bs, gm." << rest << ", write);" << std::endl;
                        impl << "    }" << std::endl;
                    }

                    if (std::find(types.begin(), types.end(), type) == types.end())
                    {
                        types.push_back(type);
                    }
                }
                break;
                case '\t':
                case ' ':
                break;
                default:
                {
                    if (open)
                    {
                        header << "};" << std::endl;
                        header << std::endl;
                        header << "void serialize(RakNet::BitStream& bs, GM_" << name << "& gm, bool write);" << std::endl;
                        header << std::endl;

                        impl << "};" << std::endl << std::endl;
                    }
                    else
                    {
                        open = true;
                    }

                    uint16_t id = std::stoul(line.substr(0,4), nullptr, 16);
                    name = line.substr(6);
                    header << "struct GM_" << name << " // ID: " << id << std::endl;
                    header << "{" << std::endl;

                    impl << "void serialize(RakNet::BitStream& bs, GM_" << name << "& gm, bool write)" << std::endl;
                    impl << "{" << std::endl;
                }
            }
        }
    }

    if (open)
    {
        header << "};" << std::endl << std::endl;
        impl << "}" << std::endl << std::endl;
    }

    impl << std::endl;

    header.close();
    impl.close();

    std::cout << std::endl << "Types" << std::endl << "-----" << std::endl << std::endl;
    for (std::string type : types)
    {
        std::cout << type << std::endl;
    }

    return 0;
}
